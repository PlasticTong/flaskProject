<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>pathpy: pathpy.HigherOrderNetwork.HigherOrderNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pathpy
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">pathpy is an OpenSource python package for the modeling and analysis of pathways and temporal networks using higher-order and multi-order graphical models</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pathpy</b></li><li class="navelem"><b>HigherOrderNetwork</b></li><li class="navelem"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html">HigherOrderNetwork</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pathpy.HigherOrderNetwork.HigherOrderNetwork Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63d36720423ee8d6d88c5a06f4655c84"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a63d36720423ee8d6d88c5a06f4655c84">__init__</a></td></tr>
<tr class="separator:a63d36720423ee8d6d88c5a06f4655c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ba7bbeb54449a87ba78eecc591fca4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a89ba7bbeb54449a87ba78eecc591fca4">vcount</a></td></tr>
<tr class="separator:a89ba7bbeb54449a87ba78eecc591fca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae425665357e88b0adf493854143a3f72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#ae425665357e88b0adf493854143a3f72">ecount</a></td></tr>
<tr class="separator:ae425665357e88b0adf493854143a3f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91626f933af603a73f8bb39249ab6c51"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a91626f933af603a73f8bb39249ab6c51">totalEdgeWeight</a></td></tr>
<tr class="separator:a91626f933af603a73f8bb39249ab6c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1963d0e4370e3818de3cf6886bba8594"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a1963d0e4370e3818de3cf6886bba8594">HigherOrderNodeToPath</a></td></tr>
<tr class="separator:a1963d0e4370e3818de3cf6886bba8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117fe621fb02d356f6591620f9340eaa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a117fe621fb02d356f6591620f9340eaa">pathToHigherOrderNodes</a></td></tr>
<tr class="separator:a117fe621fb02d356f6591620f9340eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd69fc6003eb13d11390466182a63357"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#abd69fc6003eb13d11390466182a63357">getNodeNameMap</a></td></tr>
<tr class="separator:abd69fc6003eb13d11390466182a63357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a03ec6087add6dd0b54f7264b2e21c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a3a03ec6087add6dd0b54f7264b2e21c5">getDoF</a></td></tr>
<tr class="separator:a3a03ec6087add6dd0b54f7264b2e21c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20092d5a4a182df408af6063a0887630"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a20092d5a4a182df408af6063a0887630">getDistanceMatrix</a></td></tr>
<tr class="separator:a20092d5a4a182df408af6063a0887630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672cdad613e84eb0f528bbc02e7c6163"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a672cdad613e84eb0f528bbc02e7c6163">getShortestPaths</a></td></tr>
<tr class="separator:a672cdad613e84eb0f528bbc02e7c6163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed4839be0864210c0b5aff9376fe307"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#abed4839be0864210c0b5aff9376fe307">getDistanceMatrixFirstOrder</a></td></tr>
<tr class="separator:abed4839be0864210c0b5aff9376fe307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f94ebbc8141be6f5194ec922e3b01a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a2f94ebbc8141be6f5194ec922e3b01a0">ClosenessCentrality</a></td></tr>
<tr class="separator:a2f94ebbc8141be6f5194ec922e3b01a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e8494220dd4a5b2a9a45de17f9d26a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a57e8494220dd4a5b2a9a45de17f9d26a">EvCent</a></td></tr>
<tr class="separator:a57e8494220dd4a5b2a9a45de17f9d26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc76633f53a0747353e7ab0e15744d94"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#abc76633f53a0747353e7ab0e15744d94">PageRank</a></td></tr>
<tr class="separator:abc76633f53a0747353e7ab0e15744d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71b78f1c9ffe7a06364841572f1fee2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#ab71b78f1c9ffe7a06364841572f1fee2">HigherOrderPathToFirstOrder</a></td></tr>
<tr class="separator:ab71b78f1c9ffe7a06364841572f1fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfdcfacef4f3beb7594a58600e833e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#afcfdcfacef4f3beb7594a58600e833e4">BetweennessCentrality</a></td></tr>
<tr class="separator:afcfdcfacef4f3beb7594a58600e833e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71eed8268df33814725ae7832729e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a4b71eed8268df33814725ae7832729e6">reduceToGCC</a></td></tr>
<tr class="separator:a4b71eed8268df33814725ae7832729e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35dd7f65e3bfeb280fcd38c1e7448f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#ab35dd7f65e3bfeb280fcd38c1e7448f7">summary</a></td></tr>
<tr class="separator:ab35dd7f65e3bfeb280fcd38c1e7448f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec883869195967a9209655905ace52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a4aec883869195967a9209655905ace52">__str__</a></td></tr>
<tr class="separator:a4aec883869195967a9209655905ace52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ab003f80216ed6beff9c513a7e876"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#acd9ab003f80216ed6beff9c513a7e876">degrees</a></td></tr>
<tr class="separator:acd9ab003f80216ed6beff9c513a7e876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e10f45369dff5f7ccff3bcf7e6c5b33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a8e10f45369dff5f7ccff3bcf7e6c5b33">getAdjacencyMatrix</a></td></tr>
<tr class="separator:a8e10f45369dff5f7ccff3bcf7e6c5b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c4a62ca4706bdab81534332e3843fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a20c4a62ca4706bdab81534332e3843fe">getTransitionMatrix</a></td></tr>
<tr class="separator:a20c4a62ca4706bdab81534332e3843fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ea9c565b0d8bf7f1a2d0cb409f0e15"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a69ea9c565b0d8bf7f1a2d0cb409f0e15">getLaplacianMatrix</a></td></tr>
<tr class="separator:a69ea9c565b0d8bf7f1a2d0cb409f0e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556545310735cba27128afd37c59ed35"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a556545310735cba27128afd37c59ed35">getEigenValueGap</a></td></tr>
<tr class="separator:a556545310735cba27128afd37c59ed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f3ed627c16c15c877fc0316c88bdb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#aa8f3ed627c16c15c877fc0316c88bdb3">getFiedlerVectorSparse</a></td></tr>
<tr class="separator:aa8f3ed627c16c15c877fc0316c88bdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea7800343373793dbd9688c77fb6191"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#adea7800343373793dbd9688c77fb6191">getFiedlerVectorDense</a></td></tr>
<tr class="separator:adea7800343373793dbd9688c77fb6191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48d8ad635f7cf263897016d876c6fa2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#ae48d8ad635f7cf263897016d876c6fa2">getAlgebraicConnectivity</a></td></tr>
<tr class="separator:ae48d8ad635f7cf263897016d876c6fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b757112293f9093efc437ffb113df83"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a1b757112293f9093efc437ffb113df83">getLeadingEigenvector</a></td></tr>
<tr class="separator:a1b757112293f9093efc437ffb113df83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6dea6fe6e34178adb395ad8e79403d5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dea6fe6e34178adb395ad8e79403d5c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a6dea6fe6e34178adb395ad8e79403d5c">order</a></td></tr>
<tr class="memdesc:a6dea6fe6e34178adb395ad8e79403d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The order of this <a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html">HigherOrderNetwork</a>. <br/></td></tr>
<tr class="separator:a6dea6fe6e34178adb395ad8e79403d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c8ee9f7775478793d88680d6f99fc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4c8ee9f7775478793d88680d6f99fc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#ac4c8ee9f7775478793d88680d6f99fc8">paths</a></td></tr>
<tr class="memdesc:ac4c8ee9f7775478793d88680d6f99fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The paths object used to generate this instance. <br/></td></tr>
<tr class="separator:ac4c8ee9f7775478793d88680d6f99fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6626777ff215fde5f7d92368a407c683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6626777ff215fde5f7d92368a407c683"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a6626777ff215fde5f7d92368a407c683">nodes</a></td></tr>
<tr class="memdesc:a6626777ff215fde5f7d92368a407c683"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes in this <a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html">HigherOrderNetwork</a>. <br/></td></tr>
<tr class="separator:a6626777ff215fde5f7d92368a407c683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e51491a2417e471eeb1404b44df204"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#af3e51491a2417e471eeb1404b44df204">separator</a></td></tr>
<tr class="memdesc:af3e51491a2417e471eeb1404b44df204"><td class="mdescLeft">&#160;</td><td class="mdescRight">The separator character used to label higher-order nodes.  <a href="#af3e51491a2417e471eeb1404b44df204">More...</a><br/></td></tr>
<tr class="separator:af3e51491a2417e471eeb1404b44df204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eec968e72178ab2930f83928b3ca842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eec968e72178ab2930f83928b3ca842"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a6eec968e72178ab2930f83928b3ca842">edges</a></td></tr>
<tr class="memdesc:a6eec968e72178ab2930f83928b3ca842"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary containing edges as well as edge weights. <br/></td></tr>
<tr class="separator:a6eec968e72178ab2930f83928b3ca842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522350b2e4a401732b64bb0acf1634ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522350b2e4a401732b64bb0acf1634ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a522350b2e4a401732b64bb0acf1634ea">successors</a></td></tr>
<tr class="memdesc:a522350b2e4a401732b64bb0acf1634ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary containing the list of successors of all nodes. <br/></td></tr>
<tr class="separator:a522350b2e4a401732b64bb0acf1634ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a271893d9fb656f805e36335afca257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a271893d9fb656f805e36335afca257"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a8a271893d9fb656f805e36335afca257">dof_paths</a></td></tr>
<tr class="memdesc:a8a271893d9fb656f805e36335afca257"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degrees of freedom of the higher-order model, under the paths assumption. <br/></td></tr>
<tr class="separator:a8a271893d9fb656f805e36335afca257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d69b9cc9b7b328fbd201244e68ca95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25d69b9cc9b7b328fbd201244e68ca95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathpy_1_1HigherOrderNetwork_1_1HigherOrderNetwork.html#a25d69b9cc9b7b328fbd201244e68ca95">dof_ngrams</a></td></tr>
<tr class="memdesc:a25d69b9cc9b7b328fbd201244e68ca95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degrees of freedom of the higher-order model, under the ngram assumption. <br/></td></tr>
<tr class="separator:a25d69b9cc9b7b328fbd201244e68ca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Instances of this class capture a k-th-order representation of path statistics. Path statistics 
can originate from pathway data, temporal networks, or from processes observed on top of a network topology.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a63d36720423ee8d6d88c5a06f4655c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separator</em> = <code>'-'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nullModel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'FirstOrderTransitions'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczosVecs</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates a k-th-order representation based on the given path statistics.

@param paths: An instance of class Paths, which contains the path statistics to be 
    used in the generation of the k-th order representation 

@param k: The order of the network representation to generate. For the default case of 
    k=1, the resulting representation corresponds to the usual (first-order) aggregate network, 
    i.e. links connect nodes and link weights are given by the frequency of each interaction. For 
    k&gt;1, a k-th order node corresponds to a sequence of k nodes. The weight of a k-th order link 
    captures the frequency of a path of length k.

@param separator: The separator character to be used in higher-order node names.

@param nullModel: For the default value False, link weights are generated based on the statistics of 
    paths of length k in the underlying path statistics instance. If True, link weights are generated 
    from the first-order model (k=1) based on the assumption of independent links (i.e. corresponding) 
    to a first-order Markov model.

@param method: specifies how the null model link weights in the k-th order model are calculated. 
    For the default method='FirstOrderTransitions', the weight w('v_1-v_2-...v_k', 'v_2-...-v_k-v_k+1') of 
    a k-order edge is set to the transition probability T['v_k', 'v_k+1'] in the first order network.
    For method='KOrderPi' the entry pi['v1-...-v_k'] in the stationary distribution of the 
    k-order network is used instead.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4aec883869195967a9209655905ace52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the default string representation of 
this graphical model instance
</pre> 
</div>
</div>
<a class="anchor" id="afcfdcfacef4f3beb7594a58600e833e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.BetweennessCentrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the betweenness centralities of all nodes.
If the order of the higher-order network is larger than one 
centralities calculated based on the higher-order 
topology will automatically be projected back to first-order 
nodes.

@param normalized: If set to True, betweenness centralities of 
    nodes will be scaled by the maximum value (default False)
</pre> 
</div>
</div>
<a class="anchor" id="a2f94ebbc8141be6f5194ec922e3b01a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.ClosenessCentrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the closeness centralities of all nodes.
If the order of the higher-order network is larger than one 
centralities calculated based on the higher-order 
topology will automatically be projected back to first-order 
nodes.
</pre> 
</div>
</div>
<a class="anchor" id="acd9ab003f80216ed6beff9c513a7e876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.degrees </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weighted</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;OUT&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the (weighted) degrees of nodes in the higher-order network

@param weighted: If true, calculates the sum of weights for each node. If false, the 
    number of links is calculated

@param mode: either "IN", "OUT", or "TOTAL" 
</pre> 
</div>
</div>
<a class="anchor" id="ae425665357e88b0adf493854143a3f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.ecount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of links </pre> 
</div>
</div>
<a class="anchor" id="a57e8494220dd4a5b2a9a45de17f9d26a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.EvCent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>projection</em> = <code>'scaled'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the eigenvector centralities of higher-order nodes. If 
the order of the HigherOrderNetwork is larger than one, the centralities
will be projected to the first-order nodes. 

@param projection: Indicates how the projection from k-th-order nodes (v1, v2, ... , v{k-1})
    shall be performed. For the method 'all', the eigenvector centrality of the higher-order node 
    will be added to *all* first-order nodes on the path corresponding to the higher-order node. For 
    the method 'last', the centrality of the higher-order node will only be assigned to *last* 
    first-order node v{k-1}. For the method 'scaled' (default), the eigenvector centrality of higher-order 
    nodes will be assigned proportionally to first-order nodes, i.e. each of the three nodes in the 
    third-order node (a,b,c) will receive one third of the eigenvector centrality of (a,b,c).
@param includeSubPaths: whether or not to include subpath statistics in the calculation (default True)
</pre> 
</div>
</div>
<a class="anchor" id="a8e10f45369dff5f7ccff3bcf7e6c5b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weighted</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transposed</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a sparse adjacency matrix of the higher-order network. By default, the entry 
    corresponding to a directed link source -&gt; target is stored in row s and column t
    and can be accessed via A[s,t].
    
@param includeSubPaths: if set to True, the returned adjacency matrix will 
    account for the occurrence of links of order k (i.e. paths of length k-1)
    as subpaths

@param weighted: if set to False, the function returns a binary adjacency matrix.
  If set to True, adjacency matrix entries will contain the weight of an edge.
      
@param transposed: whether to transpose the matrix or not.
</pre> 
</div>
</div>
<a class="anchor" id="ae48d8ad635f7cf263897016d876c6fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getAlgebraicConnectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczosVecs</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the algebraic connectivity of the higher-order network.    

@param lanczosVecs: number of Lanczos vectors to be used in the approximate
    calculation of eigenvectors and eigenvalues. This maps to the ncv parameter 
    of scipy's underlying function eigs. 
@param maxiter: scaling factor for the number of iterations to be used in the 
    approximate calculation of eigenvectors and eigenvalues. The number of iterations 
    passed to scipy's underlying eigs function will be n*maxiter where n is the
    number of rows/columns of the Laplacian matrix.         
</pre> 
</div>
</div>
<a class="anchor" id="a20092d5a4a182df408af6063a0887630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getDistanceMatrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates shortest path distances between all pairs of 
higher-order nodes using the Floyd-Warshall algorithm.
</pre> 
</div>
</div>
<a class="anchor" id="abed4839be0864210c0b5aff9376fe307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getDistanceMatrixFirstOrder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Projects a distance matrix from a higher-order to 
first-order nodes, while path lengths are calculated 
based on the higher-order topology
</pre> 
</div>
</div>
<a class="anchor" id="a3a03ec6087add6dd0b54f7264b2e21c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getDoF </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assumption</em> = <code>&quot;paths&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the degrees of freedom (i.e. number of parameters) of 
this k-order model. Depending on the modeling assumptions, this either
corresponds to the number of paths of length k in the first-order network 
or to the number of all possible k-grams. The degrees of freedom of a model 
can be used to assess the model complexity when calculating, e.g., the 
Bayesian Information Criterion (BIC).

@param assumption: if set to 'paths', for the degree of freedon calculation in the BIC, 
    only paths in the first-order network topology will be considered. This is 
    needed whenever we are interested in a modeling of paths in a given network topology.
    If set to 'ngrams' all possible n-grams will be considered, independent of whether they 
    are valid paths in the first-order network or not. The 'ngrams' and the 'paths' assumption 
    coincide if the first-order network is fully connected.
</pre> 
</div>
</div>
<a class="anchor" id="a556545310735cba27128afd37c59ed35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getEigenValueGap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczosVecs</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the eigenvalue gap of the transition matrix.

@param includeSubPaths: whether or not to include subpath statistics in the 
    calculation of transition probabilities.
</pre> 
</div>
</div>
<a class="anchor" id="adea7800343373793dbd9688c77fb6191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getFiedlerVectorDense </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the (dense)Fiedler vector of the higher-order network. The Fiedler 
 vector can be used for a spectral bisectioning of the network.             
</pre> 
</div>
</div>
<a class="anchor" id="aa8f3ed627c16c15c877fc0316c88bdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getFiedlerVectorSparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczosVecs</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the (sparse) Fiedler vector of the higher-order network. The Fiedler 
vector can be used for a spectral bisectioning of the network.
     
Note that sparse linear algebra for eigenvalue problems with small eigenvalues 
is problematic in terms of numerical stability. Consider using the dense version
of this method in this case. Note also that the sparse Fiedler vector might be scaled by 
a factor (-1) compared to the dense version.
  
@param normalized: whether (default) or not to normalize the fiedler vector.
  Normalization is done such that the sum of squares equals one in order to
  get reasonable values as entries might be positive and negative.
@param lanczosVecs: number of Lanczos vectors to be used in the approximate
    calculation of eigenvectors and eigenvalues. This maps to the ncv parameter 
    of scipy's underlying function eigs. 
@param maxiter: scaling factor for the number of iterations to be used in the 
    approximate calculation of eigenvectors and eigenvalues. The number of iterations 
    passed to scipy's underlying eigs function will be n*maxiter where n is the 
    number of rows/columns of the Laplacian matrix.
</pre> 
</div>
</div>
<a class="anchor" id="a69ea9c565b0d8bf7f1a2d0cb409f0e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getLaplacianMatrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the transposed Laplacian matrix corresponding to the higher-order network.

@param includeSubpaths: Whether or not subpath statistics shall be included in the 
    calculation of matrix weights
</pre> 
</div>
</div>
<a class="anchor" id="a1b757112293f9093efc437ffb113df83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getLeadingEigenvector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczosVecs</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute normalized leading eigenvector of a given matrix A.

@param A: sparse matrix for which leading eigenvector will be computed
@param normalized: wheter or not to normalize. Default is C{True}
@param lanczosVecs: number of Lanczos vectors to be used in the approximate
    calculation of eigenvectors and eigenvalues. This maps to the ncv parameter 
    of scipy's underlying function eigs. 
@param maxiter: scaling factor for the number of iterations to be used in the 
    approximate calculation of eigenvectors and eigenvalues. The number of iterations 
    passed to scipy's underlying eigs function will be n*maxiter where n is the 
    number of rows/columns of the Laplacian matrix.
</pre> 
</div>
</div>
<a class="anchor" id="abd69fc6003eb13d11390466182a63357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getNodeNameMap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dictionary that can be used to map 
node nodes to matrix/vector indices
</pre> 
</div>
</div>
<a class="anchor" id="a672cdad613e84eb0f528bbc02e7c6163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getShortestPaths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates all shortest paths between all pairs of 
higher-order nodes using the Floyd-Warshall algorithm.
</pre> 
</div>
</div>
<a class="anchor" id="a20c4a62ca4706bdab81534332e3843fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.getTransitionMatrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a (transposed) random walk transition matrix 
corresponding to the higher-order network.

@param includeSubpaths: whether or not to include subpath statistics in the 
    transition probability calculation (default True)
</pre> 
</div>
</div>
<a class="anchor" id="a1963d0e4370e3818de3cf6886bba8594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.HigherOrderNodeToPath </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function that transforms a node in a
higher-order network of order k into a corresponding 
path of length k-1. For a higher-order node 'a-b-c-d' 
this function will return ('a','b','c','d')

@param node: The higher-order node to be transformed to a path.
</pre> 
</div>
</div>
<a class="anchor" id="ab71b78f1c9ffe7a06364841572f1fee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.HigherOrderPathToFirstOrder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Maps a path in the higher-order network 
to a path in the first-order network. As an 
example, the second-order path ('a-b', 'b-c', 'c-d')
of length two is mapped to the first-order path ('a','b','c','d')
of length four. In general, a path of length l in a network of 
order k is mapped to a path of length l+k-1 in the first-order network. 

@param path: The higher-order path that shall be mapped to the first-order network
</pre> 
</div>
</div>
<a class="anchor" id="abc76633f53a0747353e7ab0e15744d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.PageRank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.85</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convergenceThres</em> = <code>1.0e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>projection</em> = <code>'scaled'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>includeSubPaths</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the PageRank of higher-order nodes based on a 
power iteration. If the order of the higher-order network is larger than one,
the PageRank calculated based on the higher-order
topology will automatically be projected back to first-order 
nodes.

@param projection: Indicates how the projection from k-th-order nodes (v1, v2, ... , v{k-1})
    shall be performed. For the method 'all', the pagerank value of the higher-order node 
    will be added to *all* first-order nodes on the path corresponding to the higher-order node. For 
    the method 'last', the PR value of the higher-order node will only be assigned to *last* 
    first-order node v{k-1}. For the method 'scaled' (default), the PageRank of higher-order 
    nodes will be assigned proportionally to first-order nodes, i.e. each of the three nodes in the 
    third-order node (a,b,c) will receive one third of the PageRank of (a,b,c).
@param includeSubpaths: whether or not to use subpath statistics in the PageRank calculation
</pre> 
</div>
</div>
<a class="anchor" id="a117fe621fb02d356f6591620f9340eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.pathToHigherOrderNodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function that transforms a path into a sequence of k-order nodes 
using the separator character of the HigherOrderNetwork instance 

Consider an example path (a,b,c,d) with a separator string '-'
For k=1, the output will be the list of strings ['a', 'b', 'c', 'd']
For k=2, the output will be the list of strings ['a-b', 'b-c', 'c-d']
For k=3, the output will be the list of strings ['a-b-c', 'b-c-d']
etc. 

@param path: the path tuple to turn into a sequence of higher-order nodes 

@param k: the order of the representation to use (default: order of the HigherOrderNetwork instance)
</pre> 
</div>
</div>
<a class="anchor" id="a4b71eed8268df33814725ae7832729e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.reduceToGCC </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reduces the higher-order network to its 
largest (giant) strongly connected component 
(using Tarjan's algorithm)
</pre> 
</div>
</div>
<a class="anchor" id="ab35dd7f65e3bfeb280fcd38c1e7448f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.summary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a string containing basic summary statistics 
of this higher-order graphical model instance
</pre> 
</div>
</div>
<a class="anchor" id="a91626f933af603a73f8bb39249ab6c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.totalEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the sum of all edge weights </pre> 
</div>
</div>
<a class="anchor" id="a89ba7bbeb54449a87ba78eecc591fca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pathpy.HigherOrderNetwork.HigherOrderNetwork.vcount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of nodes </pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af3e51491a2417e471eeb1404b44df204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pathpy.HigherOrderNetwork.HigherOrderNetwork.separator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The separator character used to label higher-order nodes. </p>
<p>For separator '-', a second-order node will be 'a-b'. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/mnt/c/Users/ingos/Desktop/pathpy/pathpy/HigherOrderNetwork.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 1 2017 10:39:09 for pathpy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
